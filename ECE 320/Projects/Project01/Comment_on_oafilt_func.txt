	My oafilt function takes three arguments: the impulse response h, the input signal x and the length of each block. At first, I take the input block's length to check if it is less than the length of the input signal x. The block length should not be negative too. If these conditions are not met, an error will be printed out and the function will be terminated. Otherwise, I continue with calculating the numbers of block at line 7 (assume the function source code file is opened with Matlab editor at the moment) and duplicating the input signal x so that I could freely work on it later on without worrying about affecting the original signal data (that might be needed in the future modifications). For the later adding purpose, I initialize the output variable y with zeroes in the length of one covolution block. The next lines of code, I divide the input signal x into the number of blocks that I caculated earlier. By using a loop, I go through every block, do convolution on it, shift it and then add it up to the output variable y. In order to do convolution on one block, I need to extract it from the whole signal and save it to the temporary variable x0. For programmatical convinience, I truncate the input signal after the extracting. This is also the reason for the earlier backup. At line 26, I convolute the extracted block and the impulse response signal. After the convolution, I shift the result to the right by one block and then add it up to the block convolution of the previous loop. The final result will be in the output variable y.
	My function accepts column vectors instead of row vectors like the solution. And because the signals in section number 3 in the project 1 are row vectors so I need to transpose them first and then plug them into my oafilt function.